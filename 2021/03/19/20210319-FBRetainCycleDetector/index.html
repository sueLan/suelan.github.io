<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="RY&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="[object Object]"/>
  
  <title>
    
      Understand How MLeaksFinder and FBRetainCycleDetector automatically detect memory leaks | RY &#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>RY 's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Understand How MLeaksFinder and FBRetainCycleDetector automatically detect memory leaks</h2>
  <p class="post-date">2021-03-19</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Memory is important resource in iOS. If a application uses too much memory, exceeding the limit based on the device, the iOS system will kill this App by sending <code>SIGKILL</code> signal. Besides, minimizing memory usage not only decreases application’s memory footprint, but also reduces the amount of CPU time it consumes. These are mentioned in several WWDC sessions. </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2011/312/">WWDC: performance and power optimization</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1">Advanced Memory Management Programming Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/219">https://developer.apple.com/videos/play/wwdc2018/219</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/">https://developer.apple.com/videos/play/wwdc2018/416/</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10078/?time=256">https://developer.apple.com/videos/play/wwdc2020/10078/?time=256</a></li>
</ul>
<p>Obviously, it is important to keep memory under control. In our daily life, we usually use Xcode memory debugger tool and instruments to detect memory leaks. Basically, lots of manual works. Maybe, a better way is to integrate memory leak detection into internal test phase or regression phase. The earlier we detect the issue, the more time we got to fix it. The less efforts we put in checking memory leaks manually, the more likely we spend less time to optimal memory issues and keep our app away from memory leaks. So, using <code>MLeaksFinder</code> and <code>FBRetainCycleDetector</code> in dev or test phase sounds like a good idea. </p>
<h1 id="What-is-MLeaksFinder-for"><a href="#What-is-MLeaksFinder-for" class="headerlink" title="What is MLeaksFinder for?"></a>What is MLeaksFinder for?</h1><p>As we know, <code>MLeaksFinder</code> is an light-weight tool from <code>WeChat</code> team, <code>Tencent</code>, which automatically finds leaks in some specific objects. When leaks happening, it will present an alert showing the leaked object and backtrace. </p>
<h1 id="How-does-MLeaksFinder-work"><a href="#How-does-MLeaksFinder-work" class="headerlink" title="How does MLeaksFinder work?"></a>How does MLeaksFinder work?</h1><p>The basic idea for <code>MLeaksFinder</code> is to set a timer when the object is about to be released. When the timer is triggered, checked if the reference to the object is still valid. If it is, this object is leaked. Then, it uses this leaked object as seed object for <code>FBRetainCycleDetector</code> to figure out the retain cycle using DFS algorithm to traversal object graph. You may see this brief introduction in some Chinese tech articles. While, I found lots of articles introducing <code>MLeakdsFinder</code> are outdated. Since its source code is a bit easy to read, let’s just start to explore it. </p>
<p><code>MLeaksFinder</code> has several categories for <a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder/tree/master/MLeaksFinder">these classes</a>: </p>
<ul>
<li>NSObject+MemoryLeak</li>
<li>UIApplication+MemoryLeak</li>
<li>UINavigationController+MemoryLeak</li>
<li>UIPageViewController+MemoryLeak</li>
<li>UISplitViewController+MemoryLeak</li>
<li>UITabBarController+MemoryLeak</li>
<li>UITouch+MemoryLeak</li>
<li>UIView+MemoryLeak</li>
<li>UIViewController+MemoryLeak</li>
</ul>
<p>Take <code>UIViewController</code> as an example, it swizzles <code>viewDidDisappear:</code> method, then checks if current view controller has been popped by <code>UINavigationController</code>. Why need this check? Because the view controller isn’t necessarily popped from view controller stack when <code>viewDidDisappear:</code> called. Maybe, another view controller just has been pushed into the view controller stack, cover it and showing on the screen.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)swizzled_viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [self swizzled_viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">objc_getAssociatedObject</span>(self, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line">        [self willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kHasBeenPoppedKey</code> tag here is set by <a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder/blob/master/MLeaksFinder/UINavigationController%2BMemoryLeak.m#L56">UINavigationController, code here</a>. </p>
<p><img src="image-20210319225704137.png" alt="image-20210319225704137"><br>As this pic demonstrates, if the view controller was released, the reference the block captured 2 seconds ago is <code>nil</code>. If this view controller isn’t released, <code>strongSelf</code> here would be a valid base address to it. Then <code>MLeakFinder</code> will show an alter to warn users. </p>
<p>We have talked about view controller, how about views?  Well, in <code>willDealloc</code> method in <code>UIViewController</code>, MLeaksFinder will run self.view’s <code>willDealloc</code>; then check <code>subviews</code> Array. Basically, the view tree in this view controller will be traversed through and checked. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">implementation <span class="title">UIView</span> <span class="params">(MemoryLeak)</span></span></span><br><span class="line"><span class="function">​</span></span><br><span class="line"><span class="function">- <span class="params">(BOOL)</span>willDealloc </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (![super willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self willReleaseChildren:self.subviews];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><img src="image-20210314194009331.png" alt="image-20210314194009331"></p>
<p>If you enable the <code>FBRetainCycleDetector</code> through macro, the current leaked object will be used as  seed object for FBRetainCycleDetector, which will detect the retain cycle. </p>
<h1 id="What-is-FBRetainCycleDetector-for"><a href="#What-is-FBRetainCycleDetector-for" class="headerlink" title="What is FBRetainCycleDetector for?"></a>What is FBRetainCycleDetector for?</h1><p>Facebook has a dedicated article about the <a target="_blank" rel="noopener" href="https://engineering.fb.com/2016/04/13/ios/automatic-memory-leak-detection-on-ios/">FBRetainCycleDetector</a></p>
<blockquote>
<p>Finding retain cycles in Objective-C is analogous to finding cycles in a directed acyclic graph in which nodes are objects and edges are references between objects (so if object A retains object B, there exists reference from A to B). Our Objective-C objects are already in our graph; all we have to do is traverse it with a depth-first search.</p>
</blockquote>
<p>So, in order to traverse the directed graph, how to get neighbors of each node? How to get objects each node references? For each node in the graph, it could be either an object or block.</p>
<h1 id="References-in-object"><a href="#References-in-object" class="headerlink" title="References in object"></a>References in object</h1><h2 id="strong-ivars"><a href="#strong-ivars" class="headerlink" title="strong ivars"></a>strong ivars</h2><p>For objects, <code>FBRetainCycleDetector</code> get its <strong>ivar list</strong> from the object. </p>
<blockquote>
<p>The first thing we can do is grab the layout of all an object’s instance variables (the “ivar layout”). For a given object, an ivar layout describes where we should look for other objects that it references.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const uint8_t *fullLayout = class_getIvarLayout(aCls);</span><br><span class="line"></span><br><span class="line">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector/blob/1ff2adee84a6ee94a1ae82526104a188774eb90a/FBRetainCycleDetector/Layout/Classes/FBClassStrongLayout.mm#L184"><code>FBClassStrongLayout</code> here</a></p>
<ol>
<li>Because <code>class_copyIvarList</code> won’t include instance variables declared by superclasses. This method has to get ivar list for current, its superclass, all the way up to its ancestoiicoder</li>
<li>get strong ivar by analyzing ivar layout</li>
<li>cache ivar list in a map, <code>&lt;Class, NSArray&lt;FBObjectReference&gt;&gt;</code></li>
</ol>
<p>Let’s understand it deeper by taking an example. For the following class, there are 4 strong references to others, 2 weak reference.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface _RCDTestClassWithMixedWeakAndStrongProperties : NSObject</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSObject *object1;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSObject *object2;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSObject *object3;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, weak) NSObject *object4;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSObject *object5;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, weak) NSObject *object6;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>using  <code>class_copyIvarList</code>, we can see its Ivar list. Each pointer is 8-byte in memory in 64-bit device, we an see the <code>offset</code> for first ivar to the class base address is <code>8 bytes</code>; the second ivar is <code>16 bytes</code>, the third one is <code>24bytes</code>, etc. </p>
<p><img src="image-20210320160316683.png" width="330" height="600"></p>
<p>Then, use <code>class_getIvarLayout</code> to get ivar layout </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *fullLayout = <span class="built_in">class_getIvarLayout</span>(aCls);</span><br></pre></td></tr></table></figure>
<p>Basically, the value of <code>fullLayout</code> is </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x03\x11&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>In  hexadecimal figure <code>\x03</code>, the high bits represents the number of <code>non-strong</code> ivar, the lower bits represents the number of <code>strong ivar</code>. <code>\x03</code> indicates that there are zero non-strong ivar and 3 strong ivar, <code>_object1</code>, <code>_object2</code>, <code>_object3</code> in this case. </li>
<li><code>x11</code> claims that there comes 1 non-strong ivar,  weak <code>_object4</code> in above declaration; and then follows 1 strong ivar <code>object5</code></li>
</ul>
<p>The following method is to parse ivar layout according to the above rule and get a set of <code>NSRange</code> for index and length for strong ivars in this class. One range is <code>1 to 3</code> and the other is <code>5</code>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> NSIndexSet *<span class="title">FBGetLayoutAsIndexesForDescription</span><span class="params">(NSUInteger minimumIndex, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layoutDescription)</span> </span>&#123;</span><br><span class="line">  NSMutableIndexSet *interestingIndexes = [NSMutableIndexSet <span class="keyword">new</span>];</span><br><span class="line">  NSUInteger currentIndex = minimumIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*layoutDescription != <span class="string">&#x27;\x00&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// how many non-strong ivar </span></span><br><span class="line">    <span class="keyword">int</span> upperNibble = (*layoutDescription &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>; </span><br><span class="line">    <span class="comment">// how many strong ivar</span></span><br><span class="line">    <span class="keyword">int</span> lowerNibble = *layoutDescription &amp; <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currentIndex is to track the first idx of strong ivar currently being analyzed from hexodecimal value</span></span><br><span class="line">    <span class="comment">// Upper nimble is for skipping `non-strong` ivar</span></span><br><span class="line">    currentIndex += upperNibble;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lower nimble describes count of the strong ivar </span></span><br><span class="line">    [interestingIndexes addIndexesInRange:<span class="built_in">NSMakeRange</span>(currentIndex, lowerNibble)];</span><br><span class="line">    currentIndex += lowerNibble;</span><br><span class="line"></span><br><span class="line">    ++layoutDescription;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interestingIndexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Idx</th>
<th>Weak/strong</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>strong</td>
<td>object1</td>
</tr>
<tr>
<td>2</td>
<td>strong</td>
<td>object2</td>
</tr>
<tr>
<td>3</td>
<td>strong</td>
<td>object3</td>
</tr>
<tr>
<td>4</td>
<td>weak</td>
<td>object4</td>
</tr>
<tr>
<td>5</td>
<td>strong</td>
<td>object5</td>
</tr>
<tr>
<td>6</td>
<td>weak</td>
<td>object6</td>
</tr>
</tbody>
</table>
<p>For the above case, the ivar layout is <code>&quot;\x03\x11&quot;</code></p>
<table>
<thead>
<tr>
<th></th>
<th>upperNibble</th>
<th>lowerNibble</th>
<th>currentIndex</th>
<th>NSRange</th>
</tr>
</thead>
<tbody>
<tr>
<td>x03</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>{1, 3}</td>
</tr>
<tr>
<td>x11</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>{5, 1}</td>
</tr>
</tbody>
</table>
<p>Parsing ivar layout to filter out the 4th and 6th ivar and get a set of index range for strong ivar. The result are two ranges, {1, 3} and {5, 1} </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSMutableIndexSet: 0x7fb7aea8ef40&gt;[number of indexes: 4 (in 2 ranges), indexes: (1-3 5)]</span><br></pre></td></tr></table></figure>
<p><img src="image-20210320161003483.png" width="375" height="500"></p>
<p>There are other interesting cases in the <a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector/blob/master/FBRetainCycleDetectorTests/FBClassStrongLayoutTests.mm">FBClassStrongLayoutTests.mm</a>, the ivar type can be structure or block, and it can be weak as well. </p>
<h2 id="References-to-associated-objects"><a href="#References-to-associated-objects" class="headerlink" title="References to associated objects"></a>References to associated objects</h2><p><code>FBRetainCycleDetector</code> hooks the calls, <code>objc_setAssociatedObject</code> and <code>objc_removeAssociatedObjects</code>. Then it store objects and a set of pointers to strongly referred associated objects into a global map. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ObjectAssociationSet = std::unordered_set&lt;<span class="keyword">void</span> *&gt;;</span><br><span class="line"><span class="keyword">using</span> AssociationMap = std::unordered_map&lt;id, ObjectAssociationSet *&gt;;</span><br></pre></td></tr></table></figure>
<p>Using  <code>OBJC_ASSOCIATION_RETAIN</code> and <code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> to trace strong references only</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy == OBJC_ASSOCIATION_RETAIN ||</span><br><span class="line">       policy == OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#123;</span><br><span class="line">     _threadUnsafeSetStrongAssociation(object, key, value);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="Block-and-captured-objects"><a href="#Block-and-captured-objects" class="headerlink" title="Block and captured objects"></a>Block and captured objects</h2><p>What attracts me most is the capability in <code>FBRetainCycleDetector</code> to detect leaked blocks and its reference.  <a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector/blob/1ff2adee84a6ee94a1ae82526104a188774eb90a/FBRetainCycleDetector/Layout/Blocks/FBBlockStrongLayout.m#L79">Amazing method to get references from the block</a> and strong reference layout in block.  </p>
<blockquote>
<p> What we can use is <a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Block-ABI-Apple.html">application binary interface for blocks</a> (ABI). It describes how the block will look in memory. If we know that the reference we are dealing with is a block, we can cast it on a fake structure that imitates a block. After casting the block to a C-struct we know where objects retained by the block are kept.</p>
</blockquote>
<p><strong> ABI for block</strong></p>
<p>First of all, let’s take a look at the Block Literal. </p>
<p>For a block like this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ &#123; <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>It will be compiled into </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*invoke)(struct __block_literal_1 *); <span class="comment">// 🌟🌟🌟 The invoke function pointer is set to a function that takes the Block structure as its first argument and the rest of the arguments (if any) to the Block and executes the Block compound statement.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_1</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __block_invoke_1(struct __block_literal_1 *_block) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> Block_size; <span class="comment">// the size of the following Block literal structure.</span></span><br><span class="line">&#125; __block_descriptor_1 = &#123; <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct __block_literal_1) &#125;</span><br></pre></td></tr></table></figure>
<p>and </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_1</span> _<span class="title">block_literal</span> =</span> &#123;</span><br><span class="line">     &amp;_NSConcreteStackBlock,</span><br><span class="line">     (<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;,</span><br><span class="line">     __block_invoke_1,</span><br><span class="line">     &amp;__block_descriptor_1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is the initialization of the block literal structure.  </p>
<p>You can use <code>clang -rewrite-objc</code> to convert the Objective-C code into cpp implementation .<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc xxxxx.m</span><br></pre></td></tr></table></figure></p>
<h2 id="What-if-the-block-has-reference-to-others"><a href="#What-if-the-block-has-reference-to-others" class="headerlink" title="What if the block has reference to others?"></a>What if the block has reference to others?</h2><h3 id="Imported-const-copy-variables"><a href="#Imported-const-copy-variables" class="headerlink" title="Imported const copy variables"></a>Imported const copy variables</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">void (^vv)(void) = ^&#123; printf(&quot;x is %d\n&quot;, x); &#125;</span><br><span class="line">x = 11;</span><br><span class="line">vv();</span><br></pre></td></tr></table></figure>
<p>It will be compiled into </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_2</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*invoke)(struct __block_literal_2 *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_2</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">// const copy variable x is here </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __block_invoke_2(struct __block_literal_2 *_block) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, _block-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_2</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> Block_size;</span><br><span class="line">&#125; __block_descriptor_2 = &#123; <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct __block_literal_2) &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_2</span> __<span class="title">block_literal_2</span> =</span> &#123;</span><br><span class="line">      &amp;_NSConcreteStackBlock,</span><br><span class="line">      (<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;,</span><br><span class="line">      __block_invoke_2,</span><br><span class="line">      &amp;__block_descriptor_2,</span><br><span class="line">      x</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>We can see the variable <code>x</code> is appended at the end of <code>__block_literal_2</code> structure.  </p>
<h3 id="Imported-const-copy-of-Block-reference"><a href="#Imported-const-copy-of-Block-reference" class="headerlink" title="Imported const copy of Block reference"></a>Imported const copy of Block reference</h3><p>In the following case, block <code>existingBlock</code> is captured by <code>vv</code>.  </p>
<ul>
<li>a Block requires <code>copy/dispose</code> helpers in block descriptor if it imports any block variables</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (^existingBlock)(<span class="keyword">void</span>) = ...;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (^vv)(<span class="keyword">void</span>) = ^&#123; <span class="built_in">existingBlock</span>(); &#125;</span><br><span class="line"><span class="built_in">vv</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_3</span> &#123;</span></span><br><span class="line">   ...; <span class="comment">// existing block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_4</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*invoke)(struct __block_literal_4 *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_4</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_3</span> *<span class="title">const</span> <span class="title">existingBlock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the invoke function for __block_literal_4</span></span><br><span class="line"><span class="keyword">void</span> __block_invoke_4(struct __block_literal_2 *_block) &#123;</span><br><span class="line">   __block-&gt;existingBlock-&gt;<span class="built_in">invoke</span>(__block-&gt;existingBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy helper is needed </span></span><br><span class="line"><span class="keyword">void</span> __block_copy_4(struct __block_literal_4 *dst, struct __block_literal_4 *src) &#123;</span><br><span class="line">     <span class="comment">//_Block_copy_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, 0);</span></span><br><span class="line">     <span class="comment">// will increase the reference counting for existingBlock</span></span><br><span class="line">     _Block_object_assign(&amp;dst-&gt;existingBlock, src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __block_dispose_4(struct __block_literal_4 *src) &#123;</span><br><span class="line">     <span class="comment">// was _Block_destroy</span></span><br><span class="line">     <span class="comment">// will decrease the reference counting for existingBlock</span></span><br><span class="line">     _Block_object_dispose(src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_4</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> Block_size;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*copy_helper)(struct __block_literal_4 *dst, struct __block_literal_4 *src);</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*dispose_helper)(struct __block_literal_4 *);</span><br><span class="line">&#125; __block_descriptor_4 = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(struct __block_literal_4),</span><br><span class="line">    __block_copy_4,</span><br><span class="line">    __block_dispose_4,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_4</span> _<span class="title">block_literal</span> =</span> &#123;</span><br><span class="line">      &amp;_NSConcreteStackBlock,</span><br><span class="line">      (<span class="number">1</span>&lt;&lt;<span class="number">25</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;</span><br><span class="line">      __block_invoke_4,</span><br><span class="line">      &amp; __block_descriptor_4</span><br><span class="line">      existingBlock,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Importing-block-variables-into-Blocks"><a href="#Importing-block-variables-into-Blocks" class="headerlink" title="Importing __block variables into Blocks"></a>Importing <code>__block</code> variables into Blocks</h3><ul>
<li>Variables of <code>__block</code> storage class are imported as a pointer to an enclosing data structure. see <a href="[Imported  copy of  reference](https://clang.llvm.org/docs/Block-ABI-Apple.html#id5">more here</a>)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __block i = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">functioncall</span>(^&#123; i = <span class="number">10</span>; &#125;);</span><br></pre></td></tr></table></figure>
<p>would be compiled into:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct _block_byref_i &#123;</span><br><span class="line">    void *isa;  // set to NULL</span><br><span class="line">    struct _block_byref_voidBlock *forwarding;</span><br><span class="line">    int flags;   //refcount;</span><br><span class="line">    int size;</span><br><span class="line">    void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);</span><br><span class="line">    void (*byref_dispose)(struct _block_byref_i *);</span><br><span class="line">    int captured_i;  // the capture variable</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __block_literal_5 &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(struct __block_literal_5 *);</span><br><span class="line">    struct __block_descriptor_5 *descriptor;</span><br><span class="line">    struct _block_byref_i *i_holder;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void __block_invoke_5(struct __block_literal_5 *_block) &#123;</span><br><span class="line">   _block-&gt;forwarding-&gt;captured_i = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __block_copy_5(struct __block_literal_5 *dst, struct __block_literal_5 *src) &#123;</span><br><span class="line">     //_Block_byref_assign_copy(&amp;dst-&gt;captured_i, src-&gt;captured_i);</span><br><span class="line">     _Block_object_assign(&amp;dst-&gt;captured_i, src-&gt;captured_i, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __block_dispose_5(struct __block_literal_5 *src) &#123;</span><br><span class="line">     //_Block_byref_release(src-&gt;captured_i);</span><br><span class="line">     _Block_object_dispose(src-&gt;captured_i, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __block_descriptor_5 &#123;</span><br><span class="line">    unsigned long int reserved</span><br><span class="line">    unsigned long int Block_size;</span><br><span class="line">    void (*copy_helper)(struct __block_literal_5 *dst, struct __block_literal_5 *src);</span><br><span class="line">    void (*dispose_helper)(struct __block_literal_5 *);</span><br><span class="line">&#125; __block_descriptor_5 = &#123; 0, sizeof(struct __block_literal_5) __block_copy_5, __block_dispose_5 &#125;;</span><br></pre></td></tr></table></figure>
<p>and </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">block_byref_i</span> <span class="title">i</span> =</span> &#123;( .isa=<span class="literal">NULL</span>, .forwarding=&amp;i, .flags=<span class="number">0</span>, .size=<span class="built_in"><span class="keyword">sizeof</span></span>(struct _block_byref_i), .captured_i=<span class="number">2</span> )&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_5</span> _<span class="title">block_literal</span> =</span> &#123;</span><br><span class="line">      &amp;_NSConcreteStackBlock,</span><br><span class="line">      (<span class="number">1</span>&lt;&lt;<span class="number">25</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;,</span><br><span class="line">      __block_invoke_5,</span><br><span class="line">      &amp;__block_descriptor_5,</span><br><span class="line">      &amp;i,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>copy_helper</code> and <code>dispose_helper</code> helper functions are added</li>
<li>a structure <code>_block_byref_i</code> is generated to store  <code>__block</code> variable; see <code>captured_i</code> in <code>_block_byref_i</code></li>
</ul>
<h3 id="import-block-object"><a href="#import-block-object" class="headerlink" title="import __block object"></a>import <code>__block</code> object</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __block NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (^blk)(<span class="keyword">void</span>) = ^() &#123;</span><br><span class="line">        obj = nil;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>structure <code>__Block_byref_obj_0</code> holds reference to <code>NSObject *obj</code> pointer. </li>
<li>need copy/dispose helper function<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_obj_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_obj_0 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*)</span><br><span class="line">  NSObject *obj; <span class="comment">// capture __block NSObject *obj </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __func_block_func_0(struct __func_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_obj_0 *obj = __cself-&gt;obj; <span class="comment">// bound by ref</span></span><br><span class="line">  (obj-&gt;__forwarding-&gt;obj) = __null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __func_block_copy_0(struct __func_block_impl_0*dst, struct __func_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __func_block_dispose_0(struct __func_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">func_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*copy)(struct __func_block_impl_0*, struct __func_block_impl_0*);</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*dispose)(struct __func_block_impl_0*);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Block-size"><a href="#Block-size" class="headerlink" title="Block_size"></a>Block_size</h2><p>From the above cases, we can see in the  descriptor structure <code>__block_descriptor_2</code>,  the <code>Block_size</code> field is sizeof(struct <code>__block_literal_2</code>) . This is a very import field.  <code>FBRetainCycleDetector</code> uses it to get the number of pointers inside</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*dispose_helper)(<span class="keyword">void</span> *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ptrSize = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Figure out the number of pointers it takes to fill out the object, rounding up.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - <span class="number">1</span>) / ptrSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Let’s take a look at a test case here. Supposed a block captures an object from outside.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSObject *object = [NSObject <span class="keyword">new</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="built_in"><span class="keyword">void</span></span> (^block)() = ^&#123;</span><br><span class="line">   __unused NSObject *someObject = object;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> NSArray *retainedObjects = <span class="built_in">FBGetBlockStrongReferences</span>((__bridge <span class="keyword">void</span> *)(block));</span><br></pre></td></tr></table></figure>
<p>The block literal is like this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct BlockLiteral &#123;</span><br><span class="line">  void *isa;  // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span><br><span class="line">  int flags;</span><br><span class="line">  int reserved;</span><br><span class="line">  void (*invoke)(void *, ...);</span><br><span class="line">  struct BlockDescriptor *descriptor;</span><br><span class="line">  // imported variables</span><br><span class="line">  const void *someObject </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="block_literal_x.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p blockLiteral-&gt;descriptor-&gt;size</span><br><span class="line">(unsigned long) $0 = 40</span><br></pre></td></tr></table></figure></p>
<ul>
<li>The value of <code>blockLiteral-&gt;descriptor-&gt;size</code> is 40, indicating the block 40 bytes in memory;</li>
<li><code>int</code> is 32 bit, <code>flags</code> and <code>reserved</code> will be put together into one word, 8 bytes in 64bit processor device. </li>
<li>In ARM64 device, the pointer size a <code>8</code> bytes.  </li>
<li>So it needs 5 pointers to fill out the fake object. </li>
</ul>
<blockquote>
<p> We create an object that pretends to be a block we want to investigate. Because we know the block’s interface, we know where to look for references this block holds. In place of those references our fake object will have “release detectors.” Release detectors are small objects that are observing release messages sent to them. These messages are sent to strong references when an owner wants to relinquish ownership. We can check which detectors received such a message when we deallocate our fake object. Knowing which indexes said detectors are in the fake object, we can find actual objects that are owned by our original block.</p>
</blockquote>
<p>Create detector for each of the pointer in the faked object. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a fake object of the appropriate length.</span></span><br><span class="line">  <span class="keyword">void</span> *obj[elements];</span><br><span class="line">  <span class="keyword">void</span> *detectors[elements];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; elements; ++i) &#123;</span><br><span class="line">    <span class="comment">// new detectors to detect whether the pointer inside obj is strong or not</span></span><br><span class="line">    FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector <span class="keyword">new</span>];</span><br><span class="line">    obj[i] = detectors[i] = detector;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Now faked object <code>obj</code> contains 5 references to 5 <code>FBBlockStrongRelationDetector</code> instances. These 5 detectors are newly created to detect whether the pointer inside obj is strong or not. They are not the original block object in your code, but with same memory layout and reference retain policy.  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void *[]) obj = ([0] = 0x00007fc07b41c370, [1] = 0x00007fc07b41f4b0, [2] = 0x00007fc07b42c080, [3] = 0x00007fc07b422820, [4] = 0x00007fc07b42e420)</span><br></pre></td></tr></table></figure>
<p><img src="image-20210320170900864.png" alt="image-20210320170900864"></p>
<p>Then, try to dispose the faked object. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">   <span class="built_in">dispose_helper</span>(obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The disposing of the fake object actually triggers <code>releasing</code> of those detectors if they are strongly referred by the fake object only. In FBBlockStrongRelationDetector, <code>release</code> message has been overridden and set <code>_strong</code> ivar to <code>YES</code> to mark the related strong reference in the <code>blockLiteral</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FBBlockStrongRelationDetector</span><br><span class="line">// set _strong as YES when received release message</span><br><span class="line">- (oneway void)release</span><br><span class="line">&#123;</span><br><span class="line">  _strong = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="image-20210320172426371.png" alt="image-20210320172426371"></p>
<p>Finally get the index of the strong reference of current block by figuring out in which <code>FBBlockStrongRelationDetector</code>, <code>_strong</code> is <code>YES</code>.  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSMutableIndexSet: 0x7fc07b41f560&gt;[number of indexes: 1 (in 1 ranges), indexes: (4)]</span><br></pre></td></tr></table></figure>
<h2 id="Detect-cycle"><a href="#Detect-cycle" class="headerlink" title="Detect cycle"></a>Detect cycle</h2><p>To detect the cycle of objects, it is doing DFS over graph of objects.<a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector/blob/1ff2adee84a6ee94a1ae82526104a188774eb90a/FBRetainCycleDetector/Detector/FBRetainCycleDetector.mm#L89"> code here</a>.  </p>
<p><img src="image-20201008115603415.png" alt="image-20201008115603415"></p>
<h1 id="Impact-on-memory-footprint"><a href="#Impact-on-memory-footprint" class="headerlink" title="Impact on memory footprint"></a>Impact on memory footprint</h1><ul>
<li><strong>MLeaksFinder</strong> is light-weight. It has <strong>few</strong> impact on memory footprint </li>
<li><strong>FBRetainCycleDetector has impact</strong> on the memory footprint<strong>.</strong> The upside is that <strong>MLeaksFinder</strong> triggers <strong>DFS in FBRetainCycleDetector</strong> on when the user click <code>Retain Cycle</code> button in the alter. After the Alert is dismissed, most of the memory usage will be gone. </li>
</ul>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h1><ul>
<li><strong>FBRetainCycleDetector</strong> is quite powerful. It can even detect leaks related to Blocks. But it is a bit slow since it uses <code>DFS</code> algorithm to traverse the object tree. Besides, there is potential risks of data race in <a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector/blob/1ff2adee84a6ee94a1ae82526104a188774eb90a/FBRetainCycleDetector/Associations/FBAssociationManager.mm#L136">associated manager</a>. </li>
<li><strong>MLeaksFinder</strong> is simple but tricky. So once it detects the leaked object, it use <strong>FBRetainCycleDetector to detect the retain cycle.</strong> Then it shows the <strong>alter.</strong></li>
<li>We can use <code>MLeaksFinder</code> to detect some seed objects. and provide <strong>FBRetainCycleDetector</strong>  with these candidate objects from which it will start detection.</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/03/05/20210305-pointer-authentication-failed/">
        <span class="nav-arrow">← </span>
        
          Crash - Pointer Authentication Failures or invalid memory accesses
        
      </a>
    
    
      <a class="nav-right" href="/2021/07/24/20210724-EXC-BREAKPOINT-in-forced-unwrapping-optional/">
        
          EXC_BREAKPOINT when forced unwrapping optional in Swift
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
  
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">scan qr code and share this article</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo="null"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Background"><span class="toc-nav-text">Background</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#What-is-MLeaksFinder-for"><span class="toc-nav-text">What is MLeaksFinder for?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#How-does-MLeaksFinder-work"><span class="toc-nav-text">How does MLeaksFinder work?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#What-is-FBRetainCycleDetector-for"><span class="toc-nav-text">What is FBRetainCycleDetector for?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#References-in-object"><span class="toc-nav-text">References in object</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#strong-ivars"><span class="toc-nav-text">strong ivars</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#References-to-associated-objects"><span class="toc-nav-text">References to associated objects</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Block-and-captured-objects"><span class="toc-nav-text">Block and captured objects</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#What-if-the-block-has-reference-to-others"><span class="toc-nav-text">What if the block has reference to others?</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Imported-const-copy-variables"><span class="toc-nav-text">Imported const copy variables</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Imported-const-copy-of-Block-reference"><span class="toc-nav-text">Imported const copy of Block reference</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Importing-block-variables-into-Blocks"><span class="toc-nav-text">Importing __block variables into Blocks</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#import-block-object"><span class="toc-nav-text">import __block object</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Block-size"><span class="toc-nav-text">Block_size</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Detect-cycle"><span class="toc-nav-text">Detect cycle</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Impact-on-memory-footprint"><span class="toc-nav-text">Impact on memory footprint</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Summary"><span class="toc-nav-text">Summary:</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://suelan.github.io/2021/03/19/20210319-FBRetainCycleDetector/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>