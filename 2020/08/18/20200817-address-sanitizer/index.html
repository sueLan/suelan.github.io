<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="RY&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="[object Object]"/>
  
  <title>
    
      Address Sanitizer | RY &#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>RY 's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Address Sanitizer</h2>
  <p class="post-date">2020-08-18</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>Memory corruption is hard to debug because it is <code>hard to consistently reproduce</code> and <code>the source of error is often far from its manifestation</code>. But with powful <code>Address Sanitizer</code> tool,  we  could achieve it.  <code>Addresss Sanitizer</code> is a LLVM-based debug tool to finds memory corruption at run time with <code>less overhead</code> at running time. And it works on OS X, iOS (simulator and device). </p>
<h3 id="Different-kinds-of-memory-corruption"><a href="#Different-kinds-of-memory-corruption" class="headerlink" title="Different kinds of memory corruption"></a>Different kinds of memory corruption</h3><ul>
<li>use after free </li>
<li>heap buffer overflow </li>
<li>Stack buffer overflow </li>
<li>global variable overflow </li>
<li>overflows in C++ containers </li>
<li>Use after return </li>
<li>Use after scope</li>
</ul>
<h3 id="How-to-enable-Address-Sanitizer"><a href="#How-to-enable-Address-Sanitizer" class="headerlink" title="How to enable Address Sanitizer"></a>How to enable Address Sanitizer</h3><ul>
<li><p>Edit Scheme </p>
</li>
<li><p>turn on the <code>Address Sanitizer</code> </p>
<p><img src="/image-20200816172927364.png" alt="image-20200816172927364"></p>
</li>
<li><p>re-compile the App</p>
</li>
</ul>
<p>This can be used together with <code>Malloc Scribble</code>.</p>
<h3 id="Xcode-Debuger-UI"><a href="#Xcode-Debuger-UI" class="headerlink" title="Xcode Debuger UI"></a>Xcode Debuger UI</h3><ol>
<li><p>showing errors </p>
<p><img src="/image-20200816210717157.png" alt="image-20200816210717157"></p>
</li>
<li><p>stacktrace </p>
<img src="image-20200816210812044.png" alt="image-20200816210812044" style="zoom:50%;" />
</li>
<li><p>memory allocation </p>
<p><img src="/image-20200816210745829.png" alt="image-20200816210745829"></p>
</li>
<li><p>Heap object </p>
<ol>
<li>faulty addresss</li>
</ol>
</li>
<li><p>Expand Memory View. It shows the allocation and deallocation backtrace of the memory. Also we can see the bytes of the object in the memory </p>
<ol>
<li>the black bytes : valid memory </li>
<li>the grey bytes: invalid memory</li>
</ol>
</li>
</ol>
<p><img src="/image-20200816213933801.png" alt="image-20200816213933801"></p>
<p>We can also see the bytes of the memory  by <code>view Memory of xxx</code></p>
<p><img src="/image-20200816213627715.png" alt="image-20200816213627715"></p>
<p>Besides, in the <code>LLDB</code>, we can run <code>memory history</code> to get the backtrace of the allocation and deallocation. </p>
<p><img src="/image-20200816214150578.png" alt="image-20200816214150578"></p>
<h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><h3 id="Heap-buffer-overflow"><a href="#Heap-buffer-overflow" class="headerlink" title="Heap buffer overflow"></a>Heap buffer overflow</h3><p><img src="/image-20200816211332451.png" alt="image-20200816211332451"></p>
<p>case from here <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=rJFoMq-RI7c">https://www.youtube.com/watch?v=rJFoMq-RI7c</a></p>
<h3 id="Use-out-of-scope-stack-memory"><a href="#Use-out-of-scope-stack-memory" class="headerlink" title="Use out of scope stack memory"></a>Use out of scope stack memory</h3><p><img src="/image-20200816211144445.png" alt="image-20200816211144445"></p>
<p><code>value</code> is a variable that inside the <code>if</code> scope. If you assign its address to <code>integer_pointer</code> and  access its memory outside the scope by using  <code>*integer_pointer</code> , it triggers <code>use of out of scope stack memory</code> </p>
<h3 id="Use-stack-memory-after-return"><a href="#Use-stack-memory-after-return" class="headerlink" title="Use stack memory after return"></a>Use stack memory after return</h3><p><img src="/image-20200816211204763.png" alt="image-20200816211204763"></p>
<p>In the c function, <code>return_address_of_stack</code> it return <code>&amp;a</code>, the address of <code>a</code> variable. While <code>a</code> is a stack variable in this function, the function returns, the stack frame will be released.  At. that time, if we try to use  <code>a</code> again, it triggers <code>use of stack memory after return</code>. </p>
<p>Use of deallocated memory </p>
<p><img src="/image-20200816213422013.png" alt="image-20200816213422013"></p>
<h2 id="When-to-Use-Address-Sanitizer"><a href="#When-to-Use-Address-Sanitizer" class="headerlink" title="When to Use Address Sanitizer"></a>When to Use Address Sanitizer</h2><ul>
<li>You project is mixed with C languages and Swift</li>
<li>Memory corruptions and crashes, which are hard to reproduce and find out the root cause</li>
<li>General debugging</li>
</ul>
<h2 id="Integrated-with-Test-and-CI"><a href="#Integrated-with-Test-and-CI" class="headerlink" title="Integrated with Test and CI"></a>Integrated with Test and CI</h2><p>Because it is less overhead than other tools and detects bugs at the run time,  we can integrate it with XCode test scheme and CI. </p>
<h4 id="In-Xcode"><a href="#In-Xcode" class="headerlink" title="In Xcode"></a>In Xcode</h4><ul>
<li>Edit Scheme – Test – Diagnostics tab</li>
<li>“Enable Address Sanitizer” checkbox</li>
<li>Build and Test</li>
</ul>
<h4 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -scheme &quot;Jogr&quot; test -enableAddressSanitizer YES</span><br></pre></td></tr></table></figure>

<h2 id="Under-the-Hood"><a href="#Under-the-Hood" class="headerlink" title="Under the Hood"></a>Under the Hood</h2><h3 id="How-Address-Sanitizer-works"><a href="#How-Address-Sanitizer-works" class="headerlink" title="How Address Sanitizer works"></a>How Address Sanitizer works</h3><p>When we enable the address sanitizer and compile a executable, Xcode pass a flag to Clang when compiling. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fsanitize=address</span><br></pre></td></tr></table></figure>

<p>After building, the instrumented executable will contain memory checks. Besides, at runtime, this binary links with <code>Asan</code> runtime dylib that contains more checks and the dylib is required by the instrumentation. </p>
<h5 id="How-this-memory-check-works"><a href="#How-this-memory-check-works" class="headerlink" title="How this memory check works?"></a>How this memory check works?</h5><p>It will check the allocations in our process. In the following graph, the blue region is the memory we allocted.  In the right side, it is the <code>Shadow memory</code> maintained by <code>Address saninitzer</code> , which tracks the real memory in the left side, telling whether the real memory is address-accessible or not.   The <code>Redzones</code> are the poisoned memory. </p>
<p><img src="/image-20200816120042864.png" alt="image-20200816120042864"></p>
<p>If the executable is compiled by enabling the Address sanitizer, every time before it access to memory, there is prefix instruction to check if this memory is<code>poisoned</code>.  If it was, the Address Sanitizer will generate a diagnostics report shown above. </p>
<p><img src="/image-20200816120700174.png" alt="image-20200816120700174"></p>
<p>The following graph shows the process is trying to access to a poisoned memory and it trigger <code>Crash</code> and genrate a diagnostic report. </p>
<p><img src="/image-20200816120921377.png" alt="image-20200816120921377"></p>
<h4 id="How-the-lookup-table-works"><a href="#How-the-lookup-table-works" class="headerlink" title="How the lookup table works"></a>How the lookup table works</h4><p>In address sanitizer, the loop up in the shadow memory should be very fast so that it will be less overhead. To achieve that, they main a look up table where every 8 bytes real memory in user process are tracked by 1 byte in the shadow memory. Even so, the loop up table is large. So they don’t allocate memory region for the lookup table. Instead, they reserve the  memory region for shadow usage.  </p>
<img src="image-20200816121732422.png" alt="image-20200816121732422" style="zoom:50%;" />

<p>Supposed the address of the real memory usage in the process is <code>Addr</code>. The address of the related shadow memory is <code>Add &gt;&gt; 3 + Offset</code>. If the value in the bytes in the shadow memory isn’t <code>0</code>,  we know the real memory is poisoned. </p>
<p><img src="/image-20200816121722926.png" alt="image-20200816121722926"></p>
<h3 id="The-heap-object-allocation"><a href="#The-heap-object-allocation" class="headerlink" title="The heap object allocation"></a>The heap object allocation</h3><p>The default Malloc implementation layout out objects in memory one after another for optimizing memory consumption.  But address sanitizer replace default Malloc implementation by using it is own allocate implementation, which lays out objects further apart from each other. </p>
<p><img src="/image-20200816123141896.png" alt="image-20200816123141896"></p>
<p>All the unused memory between objects are marked as poisoned, marked as <code>red</code> in the shadow memory.  Once  a object is free, the related shadow memory is marked as <code>red</code>, poisoned too.  Also, address sanitizer will delay reuse of free memory. So it can catch the heap buffer overflow, double-free errors, user-free etc. </p>
<h3 id="Stack-variables"><a href="#Stack-variables" class="headerlink" title="Stack variables"></a>Stack variables</h3><p><img src="/image-20200816150456865.png" alt="image-20200816150456865"></p>
<p>When enabling the Address sanitizer and compiling the executable, some red zone will be inserted between two stack variables, so stack red zones are poisoned at the runtime. </p>
<h3 id="Global-variables"><a href="#Global-variables" class="headerlink" title="Global variables"></a>Global variables</h3><p><img src="/image-20200816151834767.png" alt="image-20200816151834767"></p>
<p>They do the similar things during the compiling time for the global variables, </p>
<h2 id="Overhead"><a href="#Overhead" class="headerlink" title="Overhead"></a>Overhead</h2><ul>
<li><p>CPU slowdown usually between 2x–5x</p>
<ul>
<li>In normal case, CPU slowdown 2x-3x. In some edge case, they have seen the slowdown 5x.</li>
</ul>
</li>
<li><p>Memory overhead 2x–3x</p>
</li>
<li><p>AddressSanitizer uses more real memory than a native run. Exact overhead depends on the allocations sizes. The smaller the allocations you make the bigger the overhead is.</p>
</li>
<li><p>AddressSanitizer uses more stack memory. We have seen up to 3x increase.</p>
</li>
</ul>
<p>Still, this overhead is smaller than other tools that can do the same job. </p>
<h2 id="The-difference-in-Assembly-code"><a href="#The-difference-in-Assembly-code" class="headerlink" title="The difference in Assembly code"></a>The difference in Assembly code</h2><p>Let’s write a simple Objective-c function, and build a executable. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)testAllocation</span><br><span class="line">&#123;</span><br><span class="line">    NSString *f = @&quot;RY&quot;;</span><br><span class="line">    NSArray *a = @[@1];</span><br><span class="line">    NSLog(@&quot;%@, %@&quot;, f, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The left side is the Assembly code for normal code; the right side is the Assembly code after enabling the Address Sanitizer. </p>
<p><img src="/image-20200816171459459.png" alt="image-20200816171459459"></p>
<p>The one with Address Sanitizer enabled adds checks. The following is the shadow memory check. If the value in <code>w3</code> , the value from the shadow memory is zero. It goes the <code>loc100004894</code> label, continue to run. But if not, it will call <code>imp___stubs____asan_report_store8</code> to generate the Address sanitizer report. </p>
<p><img src="/image-20200816172007233.png" alt="image-20200816172007233"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html">Avoiding Buffer Overflows and Underflows</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2015/413">https://developer.apple.com/videos/play/wwdc2015/413</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/406">https://developer.apple.com/videos/play/wwdc2017/406</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer in LLVM doc</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=rJFoMq-RI7c">https://www.youtube.com/watch?v=rJFoMq-RI7c</a></p>
</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Debug" >
    <span class="tag-code">Debug</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/08/05/20200805-tail-call-elimination/">
        <span class="nav-arrow">← </span>
        
          Tail Call Elimination in iOS
        
      </a>
    
    
      <a class="nav-right" href="/2020/08/18/20200817-ios-main-in-assembly/">
        
          iOS main in Assembly
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
  
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">scan qr code and share this article</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Different-kinds-of-memory-corruption"><span class="toc-nav-text">Different kinds of memory corruption</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#How-to-enable-Address-Sanitizer"><span class="toc-nav-text">How to enable Address Sanitizer</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Xcode-Debuger-UI"><span class="toc-nav-text">Xcode Debuger UI</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Use-Cases"><span class="toc-nav-text">Use Cases</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Heap-buffer-overflow"><span class="toc-nav-text">Heap buffer overflow</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Use-out-of-scope-stack-memory"><span class="toc-nav-text">Use out of scope stack memory</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Use-stack-memory-after-return"><span class="toc-nav-text">Use stack memory after return</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#When-to-Use-Address-Sanitizer"><span class="toc-nav-text">When to Use Address Sanitizer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Integrated-with-Test-and-CI"><span class="toc-nav-text">Integrated with Test and CI</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#In-Xcode"><span class="toc-nav-text">In Xcode</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Command-Line"><span class="toc-nav-text">Command Line</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Under-the-Hood"><span class="toc-nav-text">Under the Hood</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#How-Address-Sanitizer-works"><span class="toc-nav-text">How Address Sanitizer works</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#How-this-memory-check-works"><span class="toc-nav-text">How this memory check works?</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#How-the-lookup-table-works"><span class="toc-nav-text">How the lookup table works</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#The-heap-object-allocation"><span class="toc-nav-text">The heap object allocation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Stack-variables"><span class="toc-nav-text">Stack variables</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Global-variables"><span class="toc-nav-text">Global variables</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Overhead"><span class="toc-nav-text">Overhead</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#The-difference-in-Assembly-code"><span class="toc-nav-text">The difference in Assembly code</span></a>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://suelan.github.io/2020/08/18/20200817-address-sanitizer/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>